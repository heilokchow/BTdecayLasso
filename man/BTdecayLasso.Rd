% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BTdecayLasso.R
\name{BTdecayLasso}
\alias{BTdecayLasso}
\title{Bradley-Terry Model with Exponential Decayed weighted likelihood and Adaptive Lasso}
\usage{
BTdecayLasso(dataframe, ability, lambda = NULL, weight = NULL,
  path = TRUE, decay.rate = 0, fixed = 1, thersh = 1e-05, max = 100,
  iter = 100)
}
\arguments{
\item{dataframe}{Generated using \code{\link{BTdataframe}} given raw data.}

\item{ability}{A column vector of teams ability, the last row is the home parameter.
The row number is consistent with the team's index shown in dataframe. It can be generated using \code{\link{BTdataframe}} given raw data.}

\item{lambda}{The amount of Lasso penalty induced. The input should be a positive scalar or a sequence.}

\item{weight}{Weight for Lasso penalty on different abilities.}

\item{path}{whether the whole Lasso path will be run (plot.BTdecayLasso is enabled only if path = TRUE)}

\item{decay.rate}{A non-negative exponential decay rate. Usually ranging from (0, 0.01), A larger decay rate weights more
importance to most recent matches and the estimated parameters reflect more on recent behaviour.}

\item{fixed}{A teams index whose ability will be fixed as 0. The worstTeam's index
can be generated using \code{\link{BTdataframe}} given raw data.}

\item{thersh}{Threshold for convergency used for Augmented Lagrangian Method.}

\item{max}{Maximum weight for w_{ij} (weight used for Adaptive Lasso)}

\item{iter}{Number of iterations used in L-BFGS-B algorithm.}
}
\value{
\item{ability}{Estimated ability scores with user given lambda}
\item{likelihood}{Negative likelihood of objective function with user given lambda}
\item{df}{Degree of freedom with user given lambda(number of distinct \eqn{\mu})}
\item{penalty}{\eqn{s/max(s)} with user given lambda}
\item{Lambda}{User given lambda}
\item{ability.path}{Estimated ability scores on whole Lasso path}
\item{likelihood.path}{Negative likelihood of objective function on whole Lasso path}
\item{df.path}{Degree of freedom on whole Lasso path(number of distinct \eqn{\mu})}
\item{penalty.path}{\eqn{s/max(s)} on whole Lasso path}
\item{Lambda.path}{Whole Lasso path}
\item{path}{Whether whole Lasso path will be run}
}
\description{
Bradley-Terry model is applied for paired comparison data. Teams' ability score is estimated by maximizing log-likelihood function.

To achieve a better track of current abilities, we apply an exponential decay rate to weight the log-likelohood function.
The most current matches will weight more than previous matches. Parameter decay.rate in most functions of this package is used
to set the amount of exponential decay rate. decay.rate should be non-negative and the approperate range of it depends on time scale in original dataframe.
(see \code{\link{BTdataframe}} and parameter "dataframe"'s definaition of fifth column) For example,
one week's time scale with a decay.rate 0.007 is the same as the one day's time scale with decay.rate 0.001. Usually, for sports matches,
if we take one day's time scale, it's ranging from 0 to 0.01. The higher choice of decay.rate, the better track of current teams' ability
with a side effect of higher variance.

If decay.rate is too large, for example 0.1 for day by day time scale, \eqn{\exp(-0.7)} = 0.50. Only half weight will be add to the likelihood with matches played
one week ago and \eqn{\exp(-3.1)} = 0.05 suggests that previous matches take place one month ago will have little effect. Therefore, there will
be only a few matches account for ability's estimation. It will lead to a very high variance and uncertainty. Since standard Bradley-Terry model
can not due with the all win and all lose cases, such estimation may not provide convergent results. Thus, if our estimation prodives divergent
result, an error will be returned and we suggest user to chose a smaller decay.rate or adding more match results in the same modeling period.

The Adaptive Lasso by default is inplemeneted for variance reduction and team's grouping. Adaptive Lasso is proved to have good grouping property.
Apart from adaptive lasso, user can define own weight for different
Lasso constriant \eqn{\left|\mu_{i}-\mu_{j}\right|} where \eqn{\mu_{i}} is team i's ability.

By default, the whole Lasso path will be run. Similar to "glmnet", user can provide their own choice of Lasso penalty "lambda" and determine whether the
whole Lasso path will be run (since such run is time-consuming). However, we suggest that if user is not familiar with the actual relationship among
lambda and the amount of peanty and the amount of shrinkage and grouping effect. We suggest user to to do a whole Lasso path run and select the
approperiate lambda through AIC or BIC criteria using \code{\link{BTdecayLassoC}} (since this model is time related, cross-validation method cannot be applied). Also, users can
use \code{\link{BTdecayLassoF}} to run with a specific Lasso penalty ranging from 0 to 1 (1 penalty means all estimators will shrink to 0).

Two sets of estimated abilities will be given, the biased Lasso estimation and the HYBRID Lasso's estimation.
HYBRID Lasso estimation solves the restricted optimization based on the group determined by Lasso's estimation (Different team's ability will converges to
the same value if Lasso penalty is added and these two teams ability is setting to be equal in the original likelihood function's optimization).

summary() function can be applied to view the outputs.
}
\details{
The objective likelihood function to be optimized is,
\deqn{\sum_{k=1}^{n}\sum_{i<j}\exp(-\alpha t_{k})\cdot(y_{ij}(\tau h_{ij}^{t_{k}}+\mu_{i}-\mu_{j})-\log(1+\exp(\tau h_{ij}^{t_{k}}+\mu_{i}-\mu_{j})))}
With the Lasso constraint,
\deqn{\sum_{i<j}w_{ij}\left|\mu_{i}-\mu_{j}\right|\leq s}
where n is the number of matches, \eqn{\alpha} is the exponential decay rate, \eqn{\tau} is the home parameter and 
\eqn{y_{ij}} takes 0 if i is defeated by j, 1 otherwise. \eqn{\mu_{i}} is the team i's ability score and penalty is 1-s/max(s).
This likelihood function is optimized using L-BFGS-B method with package \bold{optimr}. Without specifying path = FALSE, the whole lasso path will be run
and we can use plot.BTdecayLasso to do a lasso path plot
}
\examples{
##Initializing Dataframe
x <- BTdataframe(NFL2010)

\dontrun{
##BTdecayLasso run with exponential decay rate 0.005 and 
##lambda 0.1 on whole lasso path using adaptive lasso
y1 <- BTdecayLasso(x$dataframe, x$ability, lambda = 0.1, 
                   decay.rate = 0.005, fixed = x$worstTeam)
summary(y1)

##Defining equal weight
n <- nrow(x$ability) - 1
w2 <- matrix(1, nrow = n, ncol = n)
w2[lower.tri(w2, diag = TRUE)] <- 0

##BTdecayLasso run with exponential decay rate 0.005 and with a specific lambda 0.1
y2 <- BTdecayLasso(x$dataframe, x$ability, lambda = 0.1, weight = w2, 
                   path = FALSE, decay.rate = 0.005, fixed = x$worstTeam)
summary(y2)
}

}
\references{
Masarotto, G. and Varin, C.(2012) The Ranking Lasso and its Application to Sport Tournaments. 
*The Annals of Applied Statistics* **6** 1949--1970.

Zou, H. (2006) The adaptive lasso and its oracle properties. 
*J.Amer.Statist.Assoc* **101** 1418--1429.
}
\seealso{
\code{\link{BTdataframe}} for dataframe initialization,
\code{\link{plot.swlasso}},  \code{\link{plot.wlasso}} are used for Lasso path plot if path = TRUE in this function's run
}
